# another test C16_VM assembly program
#
#   compute the fast inverse square root:
#
# float Q_rsqrt( float number )
# {
# 	long i;
# 	float x2, y;
# 	const float threehalfs = 1.5F;
# 
# 	x2 = number * 0.5F;
# 	y  = number;
# 	i  = * ( long * ) &y;                       // evil floating point bit level hacking
# 	i  = 0x5f3759df - ( i >> 1 );               // what the fuck? 
# 	y  = * ( float * ) &i;
# 	y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
# 
# 	return y;
# }
# 
#   1. treat the float as a 4-byte integer type (long in the code above but int works)
#   2. bit-shift the value by 1 
#   3. subtract the result from the magic number 0x5F3759DF
#   4. perform 1 iteration of the Newton method to improve the accuracy
#  


_main_: 

    ### 1.
    # store the original float value in fa0
    FSET    fa0 3.9
    # magic number stored in 2 unsigned shorts
    # each half is in little-endian
    ISET    ia0 0xDF59
    ISET    ia1 0x375F
    # push the original float value onto the stack
    FPSH    fa0
    
    ### 2.
    # do the bit shift on the original float value
    # lower 2 bytes
    IPOP    ia2
    # upper 2 bytes
    IPOP    ia3
    # save the upper 2 bytes for later
    IPSH    ia3
    # get the last bit of ia2
    ISET    irv 0x01
    AND     ia3 irv
    # right shift the lower 2 bytes, add the final bit from the upper 2 bytes
    LSFT    ia3 0x0F
    RSFT    ia2 0x01
    IADD    ia2 ia3
    # right shift the upper 2 bytes
    IPOP    ia3
    RSFT    ia3 0x01
    
    ### 3.
    # subtract the shifted number from the magic number
    # ia0 - magic number lower 2 bytes
    # ia1 - magic number upper 2 bytes
    # ia2 - shifted number lower 2 bytes
    # ia3 - shifted number upper 2 bytes
    # subtract the lower 2 bytes first then push the result onto the stack
    ISUB    ia0 ia2
    IPSH    ia0
    # compute the carry bit
    AND     ia0 ia2
    AND     ia0 irv
    RSFT    ia2 0x01
    IADD    ia0 ia2
    # pop the low result into irv then push it onto the stack to save it
    IPOP    irv
    IPSH    irv
    # right shift one then add the contents of ia0
    RSFT    irv 0x01
    IADD    irv ia0
    # right shift the result by 15 to get the carry bit
    RSFT    irv 0x0F
    # add the carry bit to ia3 then subtract the result from ia1
    IADD    ia3 irv
    ISUB    ia1 ia3
    # pop the low result back into ia0
    IPOP    ia0
    # push the result onto the stack
    IPSH    ia1
    IPSH    ia0
    # pop the subtracted result into fa1
    FPOP    fa1
    
    ### 4.
    # 1 iteration of Newton's method on the value in fa1
    # put 0.5 into fa2 multiply by the original number 
    # then multiply by fa1 twice
    FSET    fa2 0.5
    FMUL    fa2 fa0
    FMUL    fa2 fa1
    FMUL    fa2 fa1
    # put 1.5 into fa3 then subtract fa2 from that
    FSET    fa3 1.5
    FSUB    fa3 fa2
    # multiply fa1 by fa3
    FMUL    fa1 fa3
    
    # put the final value into the return register
    FADD    frv fa1

    HALT
