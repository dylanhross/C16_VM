# another test C16_VM assembly program
#
#   compute the fast inverse square root:
#
# float Q_rsqrt( float number )
# {
# 	long i;
# 	float x2, y;
# 	const float threehalfs = 1.5F;
# 
# 	x2 = number * 0.5F;
# 	y  = number;
# 	i  = * ( long * ) &y;                       // evil floating point bit level hacking
# 	i  = 0x5f3759df - ( i >> 1 );               // what the fuck? 
# 	y  = * ( float * ) &i;
# 	y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
# 
# 	return y;
# }
# 
#   1. treat the float as a 4-byte integer type (long in the code above but int works)
#   2. bit-shift the value by 1 
#   3. subtract the result from the magic number 0x5F3759DF
#   4. perform 1 iteration of the Newton method to improve the accuracy
#  


_main_: 
    # store the original float value in fa0
    FSET    fa0 3.9
    # magic number stored in 2 unsigned shorts
    ISET    ia0 0x375F
    ISET    ia1 0xDF59
    # push the original float value onto the stack
    FPSH    fa0
    # do the bit shift on the original float value
    # lower 2 bytes
    IPOP    ia2
    # upper 2 bytes
    IPOP    ia3
    # save the upper 2 bytes for later
    IPSH    ia3
    # get the last bit of ia2
    ISET    irv 0x0001
    AND     ia3 irv
    # right shift the lower 2 bytes, add the final bit from the upper 2 bytes
    RSFT    ia3 0x0F
    RSFT    ia2 0x01
    IADD    ia2 ia3
    # right shift the upper 2 bytes
    IPOP    ia3
    RSFT    ia3 0x01
    
    
    # subtract the shifted original number (in ia2 and ia3) from
    # the magic number (in ia0 and ia1)

    ISUB    ia0 ia2
    IPSH    ia0
    IPSH    ia0
    ISET    irv 0x01
    AND     ia0 ia2
    AND     ia0 irv
    IPOP    irv
    RSFT    ia2 0x01
    RSFT    irv 0x01
    IADD    ia0 ia2
    IADD    ia0 irv
    IADD    ia3 ia0
    ISUB    ia1 ia3
    IPOP    ia0
    


    
    
    # push the subtracted result onto the stack then pop into fa1
    IPSH    ia1
    IPSH    ia0
    FPOP    fa1
    # 1 iteration of Newton's method on the value in fa1
    # put 0.5 into fa2 then multiply by fa1 twice
    #FSET    fa2 0.5
    #FMUL    fa2 fa1
    #FMUL    fa2 fa1
    # put 1.5 into fa3 then subtract fa2 from that
    #FSET    fa3 1.5
    #FSUB    fa3 fa2
    # multiply fa1 by fa3
    #FMUL    fa1 fa3
    # put the final value into the return register
    #FADD    frv fa1



    
    HALT





    

    

